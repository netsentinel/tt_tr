# tt_koshru
## frontend endpoints
- / - react fronend root path
  - /writer
  - /reader
  - /history
- /swagger - swagger root path
## launch on port 4000
```
docker compose up
```
or
```
buildkitd
```
```
nerdctl compose up
```
![image](https://github.com/user-attachments/assets/d12c6fb6-12da-4b69-bada-89c41094916e)
## почему такая сложная реалиция эндпоинта вебсокета?
Система должна гарантировать, что с момента подключения вебсокета ни одного сообщения не было пропущено, при том, при коротковременных разрывах, должна быть способна восстанаить подключение с получением всех пропущенных сообщений. Эндпоинт должен работать асинхронно и не обращаться к базе.
### Метод `AddMessage` класса `MessageRealtimeService`
1. Блокирует `_messages` и добавляет в него сообщение, устанавливая пропс `LastMessageId`.
2. Проверяет, достиг ли кеш `_messages` большого размера. Если да, то удаляет из него 7/8 записей и инкрементирует поле `_version`.
3. Снимает блокировку.
4. Вызывает событие `MessageAdded`;
### Метод `WebSocketMessagesStream` класса `MessageController`
1. Создаёт асинхронное ожидание `var tcs = new TaskCompletionSource`, ждущее отстрела события `MessageRealtimeService`.`MessageAdded`.
2. Проверяет наличие сообщений для передачи клиенту методом `GetUpdates` класса `MessageRealtimeService` (клиент сообщает, какое последнее сообщение у него присутствует; если таковых нет - за него принимается `LastMessageId`). Если обновления есть - отправляет их клиенту `webSocket.SendAsync`.
3. Встаёт в созданное ранее ожидание `await tcs.Task`.
### Метод `GetUpdates` класса `MessageRealtimeService`
1. Сохраняет в локальную перменную `version` значение поля `_version`.
2. Бинарным поиском находит сообщение, следующее за последним на клиенте. Начиная с него, записывает себе локально все сообщения.
3. Проверяет поле `_version`: если изменилось в процессе формирования коллекции обновления, процесс начинается сначала (оптимистичная блокировка).

Таким образом, в системе существует одна блокировка - для добавления собщения - добавления ссылки в список, крайне быстрой операции. При этом существует защита от слишком частых очисток этого кэша, чтобы даже на большом количестве обращений время блокировки было минимальным. Всё остальное работает асинхронно. Отдельно поясню, что ожидание `var tcs = new TaskCompletionSource<bool>();` создаётся до проверки обновлений именно потому, что если его создавать после, обновление может прийти в момент создания ожидания и подписывания его на событие, т.е. будет доставлено, но вместе со следующим, чего мы не хотим. Этого нельзя избежать без дополнительной блокировки. Если обновлений нет, выход из метода `GetUpdates` будет очень быстрым (`if(_messages[^1].Id <= sinceId)`) и не является проблемой. 

Рассматривая некоторые другие реализации, стоит сразу же начать с того, что метод WebSocket.SendAsync не является потоко-безопасным. Это сразу отметает все варианты типа подписать его напрямую на событие Action<Message> MessageAdded - два сообщения могут прийти одновременно. Существует много других вариантов, очевидно, более простых, но я не смог придумать варианта, занимающего меньшее время на блокировку, чем описанный выше.

Вариант с ConcurrentBag и оптимистичной блокировкой захлебнется на большом количестве запросов - они просто будут выбивать оптимистичную блокировку постоянно, на каком-то этапе система коллапсирует - количество неотправленных сообщений растет, следственно увеличивается время создания отправляемого слайса, следственно оптимистичная блокировка выбивается с ещё большей вероятностью. Красота решения с листом в том, что его не нужно блокировать для получения слайса. Даже если в момент его формирования будет взята блокировка (например уже внутри метода Slice, где-нибудь посреди него), добавляемый элемемент не попадет в слайс, т.к. его размер заранее задается, нет проблемы получения corrupted состояния списка. Т.е. новые сообщения можно добавлять параллельно формированию слайса обновлений (нельзя параллельно добавлять два сообщения, для этого нужно блокировка). 

Одна проблема остаётся нерешенной. В моём случае, при добавлении сообщения, список может переформировать внутренний массив, что, в теории, может привести к повреждению извлекаемых элементов. Возможно, стоит заранее аллоцировать максимальный размера кэша целиком.
